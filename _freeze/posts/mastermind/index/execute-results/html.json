{
  "hash": "897cb683724552b25feb008e2801d3f3",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Mastermind\"\nauthor: \"Martín Suárez Álvarez\"\ndate: \"2025-02-09\"\ncategories: [news, code, game]\nimage: \"board.jpg\"\n---\n\n\n\nSo this is the 1st post :) I wanted to share a piece of code that I did just for fun after discovering the board game [Mastermind](https://en.wikipedia.org/wiki/Mastermind_(board_game)). In this case, the computer samples 5 times from a set of 8 colors with replacement, and the user will try to guess the colors that were chosen and their position. This is done in R, and visualized through 2 plots (using ```ggplot2```) that are shown together using ```patchwork``` to simulate the actual board. \n\nThis is a Mastermind board, with 4 colors. If the player has guessed the position, it's indicated with a red \"pointer\", and if the player has guessed the color but not the position, it's indicated with a white pointer. \n\n![board](board.jpg)\n\nIn my case, I chose to play with 5 colors, unlimited opportunities, and black for the guessed position and white for the guessed color. This is an example of how the \"board\" looks using my code:\n\n\n\n\n## Code\n\nHere you can see the code. As a summary, I just created 2 functions:\n- The function ```reset()```, that sets the number of tries to 1, samples 5 times from the colors, and sets everything to \"default\" to start a new game.\n- The function ```play()```, that begins a player turn. It lets the player write the 5 colors, and will create a dataframe with the current play, and set the colors (black/white/grey) for the pointers depending on whether the positions and colors that the user chose are correct. Then, it will append this dataframe to the previous turns in the ```game``` dataframe. This allows for plotting all the turns together, having a global view of the play (it's important for the development of the game). \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# import packages\nlibrary(ggplot2)\nlibrary(patchwork)\n\n# colors to sample from\ncolors = c('red', 'yellow', 'orange', 'pink', 'black', 'white', 'green', 'blue')\n\n# create reset function: set number of tries to 0, sample colors, and save variables to global environment\nreset = function() {\n  cpu_cols = sample(colors, replace = TRUE, size = 5)\n  game = data.frame(matrix(nrow = 0, ncol = 5)) # create empty \"game\" dataframe\n  colnames(game) = c('try', 'cpu', 'player', 'pointer', 'pos')\n  num_try = 1 # number of tries\n  assign(\"cpu_cols\", cpu_cols, envir = .GlobalEnv)\n  assign(\"game\", game, envir = .GlobalEnv)\n  assign(\"num_try\", num_try, envir = .GlobalEnv)\n}\n\n# create play function: let user choose 5 colors, update the \"game\" dataframe and plot the results\nplay = function() {\n  # let player choose colors\n  print(\"Choose color in position 1\")\n  col1 = readline()\n  print(\"Choose color in position 2\")\n  col2 = readline()\n  print(\"Choose color in position 3\")\n  col3 = readline()\n  print(\"Choose color in position 4\")\n  col4 = readline()\n  print(\"Choose color in position 5\")\n  col5 = readline()\n  player_cols = c(col1, col2, col3, col4, col5)\n  \n  if (!(all(player_cols %in% colors))) {\n    return(print(\"Insert a valid color\"))\n  }  # get error message if color is not valid\n  \n  # create dataframe of colors from cpu and player\n  current_try = data.frame(\n    try_num = rep(num_try, length(player_cols)),\n    cpu = cpu_cols,\n    player = player_cols,\n    pointer = rep('grey', 5),\n    pos = seq(1:length(player_cols))\n  )\n  \n  num_try = num_try + 1 # update value of num_try\n  assign(\"num_try\", num_try, envir = .GlobalEnv) # save num_try to global env\n  \n  # checking if position is right and col is right\n  black = 0\n  white = 0\n  for (i in seq(1:nrow(current_try))) {\n    if (current_try$cpu[i] == current_try$player[i]) {\n      black = black + 1\n    } else if (current_try$player[i] %in% current_try$cpu) {\n      white = white + 1\n    }\n  }\n  \n  if (black != 0) {\n    current_try$pointer[1:black] = 'black' # correct positions\n  }\n  \n  if (white != 0) {\n    current_try$pointer[(black + 1):(black + white)] = 'white' # correct colors\n  }\n  \n  game = rbind(game, current_try) # update game dataframe\n  assign(\"game\", game, envir = .GlobalEnv)\n  \n  # plot board\n  player = game |> ggplot(aes(y = try_num, x = pos)) + \n    geom_point(size = 10, fill = game$player, col = 'black', pch = 21) +\n    theme(panel.background = element_rect(fill = 'white'),\n          panel.border = element_rect(color = 'black', fill = NA),\n          text = element_text(size = 20)) + \n    scale_y_continuous(breaks = c(1:num_try), n.breaks = num_try) + \n    xlab('') +\n    ylab('')\n  \n  pointer = game |> ggplot(aes(y = try_num, x = pos)) + \n    geom_point(size = 10, fill = game$pointer, col = 'black', pch = 21) +\n    theme(panel.background = element_rect(fill = 'white'),\n          panel.border = element_rect(color = 'black', fill = NA),\n          text = element_text(size = 20)) + \n    scale_y_continuous(breaks = c(1:num_try), n.breaks = num_try) + \n    xlab('') +\n    ylab('# Try')\n  \n  list_for_end = list(pointer + player & plot_layout(guides = 'collect'), \"You won\") # winning output\n  \n  if (all(current_try$pointer == c(rep('black', 5)))) {\n    return(list_for_end) # winning message\n  }\n  \n  return(pointer + player & plot_layout(guides = 'collect')) # return plots\n}\n\n# Initialize the game\nreset()\n\n# Start playing\nplay()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Choose color in position 1\"\n\n[1] \"Choose color in position 2\"\n\n[1] \"Choose color in position 3\"\n\n[1] \"Choose color in position 4\"\n\n[1] \"Choose color in position 5\"\n\n[1] \"Insert a valid color\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsessionInfo()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nR version 4.4.3 (2025-02-28)\nPlatform: x86_64-conda-linux-gnu\nRunning under: Ubuntu 22.04.3 LTS\n\nMatrix products: default\nBLAS/LAPACK: /home/martin/programs/miniforge3/envs/web/lib/libopenblasp-r0.3.29.so;  LAPACK version 3.12.0\n\nlocale:\n [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              \n [3] LC_TIME=es_ES.UTF-8        LC_COLLATE=en_US.UTF-8    \n [5] LC_MONETARY=es_ES.UTF-8    LC_MESSAGES=en_US.UTF-8   \n [7] LC_PAPER=es_ES.UTF-8       LC_NAME=C                 \n [9] LC_ADDRESS=C               LC_TELEPHONE=C            \n[11] LC_MEASUREMENT=es_ES.UTF-8 LC_IDENTIFICATION=C       \n\ntime zone: Europe/Madrid\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] patchwork_1.3.0 ggplot2_3.5.1  \n\nloaded via a namespace (and not attached):\n [1] vctrs_0.6.5       cli_3.6.4         knitr_1.49        rlang_1.1.5      \n [5] xfun_0.51         jsonlite_1.9.1    glue_1.8.0        colorspace_2.1-1 \n [9] htmltools_0.5.8.1 scales_1.3.0      rmarkdown_2.29    grid_4.4.3       \n[13] evaluate_1.0.3    munsell_0.5.1     tibble_3.2.1      fastmap_1.2.0    \n[17] yaml_2.3.10       lifecycle_1.0.4   compiler_4.4.3    pkgconfig_2.0.3  \n[21] farver_2.1.2      digest_0.6.37     R6_2.6.1          pillar_1.10.1    \n[25] magrittr_2.0.3    tools_4.4.3       withr_3.0.2       gtable_0.3.6     \n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}