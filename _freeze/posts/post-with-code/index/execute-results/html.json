{
  "hash": "373a4b94e5217e6c10c82c07d69ccd31",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Mastermind\"\nauthor: \"Martín Suárez Álvarez\"\ndate: \"2025-02-09\"\ncategories: [news, code, game]\nimage: \"image.jpg\"\n---\n\n\n\nSo this is the 1st post :) I wanted to share a piece of code that I did just for fun after discovering the board game [Mastermind](https://en.wikipedia.org/wiki/Mastermind_(board_game)). In this case, the computer samples 5 times from a set of 8 colors with replacement, and the user will try to guess the colors that were chosen and their position. This is done in R, and visualized through 2 plots (using ```ggplot2```) that are shown together using ```patchwork``` to simulate the actual board. \n\nThis is a Mastermind board, with 4 colors. If the player has guessed the position, it's indicated with a red \"pointer\", and if the player has guessed the color but not the position, it's indicated with a white pointer. \n\n<img src=\"https://sv.wikipedia.org/wiki/Mastermind#/media/Fil:Mastermind.jpg\" width=\"400\" />\n\nIn my case, I chose to play with 5 colors, unlimited opportunities, and black for the guessed position and white for the guessed color. This is an example of how the \"board\" looks using my code:\n\n\n## Code\n\nHere you can see the code. As a summary, I just created 2 functions:\n- The function ```reset()```, that sets the number of tries to 1, samples 5 times from the colors, and sets everything to \"default\" to start a new game.\n- The function ```play()```, that begins a player turn. It lets the player write the 5 colors, and will create a dataframe with the current play, and set the colors (black/white/grey) for the pointers depending on whether the positions and colors that the user chose are correct. Then, it will append this dataframe to the previous turns in the ```game``` dataframe. This allows for plotting all the turns together, having a global view of the play (it's important for the development of the game). \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# import packages\n\nlibrary(ggplot2)\nlibrary(patchwork)\n\n# colors to sample from\n\ncolors = c('red' , 'yellow' , 'orange',\n           'pink' , 'black' , 'white' ,\n           'green' , 'blue') \n\n# create reset function: set number of tries to 0, sample colors, and\n# save variables to global environment\n\nreset = function(){\n  \n  cpu_cols = sample(colors , replace = T , size = 5)\n\n  game = data.frame(matrix(nrow = 0 , ncol = 5)) # create empty \"game\" dataframe\n  colnames(game) = c('try' , 'cpu' , 'player' , 'pointer' , 'pos')\n\n  try = 1 # number of try \n  \n  assign(\"cpu_cols\" , cpu_cols , envir = .GlobalEnv)\n  assign(\"game\" , game , envir = .GlobalEnv)\n  assign(\"try\" , try , envir = .GlobalEnv)\n\n}\n\n\n\n\n# create play function: let user choose 5 colors, update the \"game\" dataframe\n# and plot the results\n\nplay = function(){\n  \n   # let player choose colors\n    print(\"Choose color in position 1\")\n    col1 = readline()\n    \n    print(\"Choose color in position 2\")\n    col2 = readline()\n    \n    print(\"Choose color in position 3\")\n    col3 = readline()\n    \n    print(\"Choose color in position 4\")\n    col4 = readline()\n    \n    print(\"Choose color in position 5\")\n    col5 = readline()\n    \n    player_cols = c(col1,col2,col3,col4,col5)\n    \n    if(!(all(player_cols %in% colors))){\n      return(print(\"Insert a valid color\")) \n    }  # get error message if color is not valid\n    \n    \n  # create dataframe of colors from cpu and player \n    \n    current_try = data.frame(try_num = rep(try , length(player_cols)) , \n               cpu = cpu_cols , \n               player = player_cols,\n               pointer = rep('grey' , 5),\n               pos = seq(1:length(player_cols)))\n    \n    \n    try = try + 1 # update value of try\n    assign(\"try\" , try , env = .GlobalEnv) # save try to global env\n    \n  # checking if position is right and col is right\n    \n    black = 0\n    white = 0\n    for(i in seq(1:nrow(current_try))){\n      \n      if(current_try$cpu[i] == current_try$player[i]){\n        black = black + 1\n      }\n    \n      else if(current_try$player[i] %in% current_try$cpu){\n        white = white + 1\n      }\n    }\n    \n    if(black != 0){\n    current_try$pointer[1:black] = 'black' # correct positions\n    }\n    \n    if(white != 0){\n    current_try$pointer[(black + 1):(black+white)] = 'white' # correct colors\n    }\n    \n    \n    game = rbind(game , current_try) # update game dataframe\n    assign(\"game\" , game , env = .GlobalEnv)\n    \n\n    # plot board\n\n    player = game |> ggplot(aes(y = try_num , x = pos)) + \n        geom_point(size = 10 , fill = game$player,\n                   col = 'black' , pch = 21) +\n        theme(panel.background = element_rect(fill = 'white'),\n              panel.border = element_rect(color = 'black',\n                                          fill = NA),\n              text = element_text(size = 20)) + \n        scale_y_continuous(breaks = c(1:try) , n.breaks = try) + \n        xlab('') +\n        ylab('')\n    \n    \n    \n    \n    pointer = game |> ggplot(aes(y = try_num , x = pos)) + \n        geom_point(size = 10 , fill = game$pointer,\n                   col = 'black' , pch = 21) +\n        theme(panel.background = element_rect(fill = 'white'),\n              panel.border = element_rect(color = 'black',\n                                          fill = NA),\n              text = element_text(size = 20)) + \n        scale_y_continuous(breaks = c(1:try), n.breaks = try) + \n        xlab('') +\n        ylab('# Try') \n    \n    list_for_end = list(pointer + player & plot_layout(guides = 'collect'),\n                        \"You won\") # winning output\n    \n    \n    \n    if(all(current_try$pointer == c(rep('black' , 5)))){\n      return(list_for_end) # winning message\n    }\n    \n    \n    return(pointer + player & plot_layout(guides = 'collect')) # return plots\n}\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}